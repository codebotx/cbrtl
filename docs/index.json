[{"content":"Inspired by KoalasToTheMax, QTree is a short live demonstration of image compression and decompression using Quadtrees, that partitions a two-dimensional image by recursively subdividing it into four quadrants.\n","permalink":"https://anubhavp.dev/blog/posts/pages/qtree/","summary":"Inspired by KoalasToTheMax, QTree is a short live demonstration of image compression and decompression using Quadtrees, that partitions a two-dimensional image by recursively subdividing it into four quadrants.","title":"Image Compression using Quadtree"},{"content":"Rust is a multi-paradigm systems programming language created to ensure high performance similar to that offered by C and C++, but with emphasis on code safety, the lack of which is probably why C and C++ are painful to deal with. It accomplishes memory safety without using a dedicated garbage collector. Rust is also an ahead-of-time compiled language, which means that you can compile a rust program, give it to someone else, and they can run it even without having Rust installed. However, Rust has more than just memory safety on its side. High performance while processing large amounts of data, support for concurrent programming, and an effective compiler are other reasons why well-known software heavyweights such as Firefox, Dropbox, Cloudflare, and many web-3 startups and large corporations use Rust in production.\nSome questions that may come to your mind are:\nIf Rust is created to achieve performance similar to that offered by C++, then why not use C++ instead? I know Java, JavaScript, and Python to be more popular choices amongst peers. Why not use those languages instead? What about new languages like Go, Kotlin, Swift, etc.? To answer these questions, let us first go through how a programming language works.\nProgramming Languages and their working A programming language is a set of instructions that can be used to interact with and control a computer. These languages can be used for a multitude of purposes, such as creating a website, analyzing data, writing a program to solve a mathematical problem, creating a game, piloting a car, building a robot, making rockets take off, controlling spacecraft and the list goes on. A computer, even though can control a rover on Mars, detect an incoming ballistic missile, and detonate it before it reaches you, cannot understand English, or anything else except \u0026lsquo;0\u0026rsquo; \u0026amp; \u0026lsquo;1\u0026rsquo;. Computers can be thought of to be made up of tiny switches, and can be either \u0026lsquo;on\u0026rsquo; (1) or \u0026lsquo;off\u0026rsquo; (0) called \u0026lsquo;bits\u0026rsquo;. Whatever instruction you want to execute on a computer, has to be converted into a series of \u0026lsquo;0\u0026rsquo;s and \u0026lsquo;1\u0026rsquo;s before it can be executed. Even a simple \u0026ldquo;Hi\u0026rdquo; is parsed as 01001000 01101001. Yes, this is what Siri responds when you Hey Siri. Since the English language is vast and complicated, it is not possible to convert it into a series of \u0026lsquo;0\u0026rsquo; and \u0026lsquo;1\u0026rsquo; directly. A subset of English or any other language is created, which is called a programming language. High-Level Programming Languages have English-like syntax and are designed to be easy to read and write, whereas low-Level Programming Languages are designed to be easy for the computer to understand. To make things easier for us, there are tools that convert whatever we want the computer to do into a series of \u0026lsquo;0\u0026rsquo;s and \u0026lsquo;1\u0026rsquo;s. This series of \u0026lsquo;0\u0026rsquo;s and \u0026lsquo;1\u0026rsquo;s is then executed by the computer.\nCompilers and interpreters A compiler or an interpreter is a tool that converts a program written in a programming language (source code) into a series of \u0026lsquo;0\u0026rsquo;s and \u0026lsquo;1\u0026rsquo;s that can be executed by a computer. Compilers and interpreters differ in the way they work. A compiler converts the entire program into a series of \u0026lsquo;0\u0026rsquo;s and \u0026lsquo;1\u0026rsquo;s (machine code) and then executes it. An interpreter, on the other hand, executes the program line by line.\nWhy did we need interpreters?\nCompiled languages need a “build” step. You need to compile your program before you can run it. To run your program on a different computer, you will have to compile it on that computer as well. Interpreters run through a program line by line and execute each command. You can run a program without having to compile it first. This makes it easier to run programs on different computers.\nAnother notable disadvantage of compilers is platform dependency of the generated binary code. Compilers are designed to be CPU specific and run on a specific CPU architecture. This means that if you want to run a program on a different CPU architecture, you will have to compile it again.\nWhy do we still make use of compilers ?\nCompilers are designed to be CPU specific, and as a result, they tend to be a lot faster and more efficient than interpreters. They also give the developer more control over hardware aspects, like memory management and CPU usage.\nA compiler is faster and more efficient than an interpreter, but an interpreter is easier to write than a compiler.\nCompiled Vs Interpreted languages Interpreted languages were once significantly slower than compiled languages. But, with the development of just-in-time compilation, that gap is shrinking. Modern scripting languages like Python and JavaScript are compiled to machine code at runtime using both compilers and interpreters, which makes them as fast as compiled languages. They are first compiled into an intermediate representation called bytecode, and then interpreted by a virtual machine which converts it to machine code.\nIf you\u0026rsquo;re wondering what language should you choose to build your next project with, ask yourself this: what kind of platform do I want the application to run in? If you want to run your application on a web browser, you should go with JavaScript or TypeScript. If you want to run your application on a server, you may want to use Python or Go. In a mobile device, Swift or Kotlin might be the way to go. C++ is used for building complex applications and systems software, such as operating systems, browsers, and video games which require a heavy performance overhead.\nRust, Go and C++ are popular compiled languages that are used for building high-performance applications. Python and JavaScript are popular interpreted languages that are used for building web applications.\nThe speed advantage of the compiled language such as Golang (Go) in comparison to an interpreted language such as Java is one of the reasons why organizations write their microservices in Go. In complex computing environments such as cloud computing environments, where users get charged for every clock cycle, it makes sense to use the most efficient deployment artifact.\nC++: The king of programming languages C++ is a low-level, statically typed object-oriented language that allows you to have a good grasp of your computer\u0026rsquo;s resources and utilize them at your convenience. Since it is a compiled language, it surpasses the performance of most of the other interpreted languages. It is an extremely powerful language and is used in many applications such as operating systems, video games, the development of compilers and interpreters, etc. It has a huge community and is one of the most popular languages in the world.\nReasons why C++\u0026rsquo;s performance is unparalleled:\nA compiled language. C++ is extremely fast because it is a compiled language. A low-level language. It allows you to cheaply use computing resources. Statically typed. It allows the compiler to optimize the code. Object-oriented programming. It allows you to create reusable code. A general purpose language. It can be used to create any kind of application. The issue with C++ boils down to how it manages memory. C++ is prone to memory leaks and dangling pointers, if not written properly.\nMemory Management in programming languages Variables are named memory locations that store data. A variable is a container that holds a value. The value can be of any type, such as integer, float, character, etc. Example:\nint a = 10;\rfloat b = 10.5;\rchar c = 'a';\rComputer programs need to allocate memory to store variables, data values, and data structures and deallocate memory when done using them. Memory is also used to store the program itself and the run-time system needed to support it. Programming languages can be categorized as those which provide automatic memory management and those which ask the programmer to allocate and free memory manually. Requiring the programmer to manage memory manually leads to a simpler compiler and run-time but requires more work from the programmer and is more error-prone. While automatic memory management is more convenient for the programmer, it is also more complex and slower and it is achieved by the use of garbage collection.\nC++ C++ is a low-level language with manual memory management. C++ programs manually allocate and free memory using pointers.\nPointers Pointers are variables that store the address of another variable and access the memory location of a variable. Pointers are used to pass large data structures to functions, to return multiple values from a function, to dynamically allocate memory, etc. Since there is no automatic memory management in C++, you need to be responsible for allocating and freeing memory. This process is achieved using the malloc, calloc, new, and delete keywords.\nWith manual memory management, a few things can go wrong like memory leaks and dangling pointers. For instance, the dangling pointer problem arises when there is an attempt to use a pointer after it has been freed. Dangling pointer errors can arise whenever there is an error in the control flow logic of a program. The use of a pointer before allocation may be a fatal run-time error. Use after deallocation is not always fatal but neither of these is a good thing.\n#include \u0026lt;stdio.h\u0026gt; int main() { int *ptr=(int *)malloc(sizeof(int)); int a=560; ptr=\u0026amp;a; free(ptr); // dangling pointer printf(\u0026#34;%d\u0026#34;,*ptr); return 0; } The above code will produce a segmentation fault since the pointer is pointing to a memory location that has been freed. To avoid this, we can set the pointer to NULL after freeing it.\nfree(ptr); ptr=NULL; Memory leaks and dangling pointer bugs are some reasons why C++ is not preferred for applications that require a lot of memory management. To avoid such issues, languages that provide automatic memory management are preferred over C++. Scripting languages manage memory using a garbage collector.\nGarbage collection Garbage is a memory that was once used by objects but will never be read or written by the program again. A garbage collector (GC) is a background process that provides automatic memory management for modern languages by taking care of the allocation and deallocation of a program’s computer memory resources. As a result, certain categories of bugs are eliminated or substantially reduced such as:-\nDangling pointer bugs - a piece of memory is freed, but the objects still have references – one of these references is used in the program.\nDouble-free bugs – the program attempts to free a piece of memory that has already been freed.\nMemory leaks – if a program does not free memory that is no longer referenced by any object, it can lead to memory exhaustion over time.\nGarbage collection seemed like a really good solution to the memory leak issues occurring in low-level languages such as C/C++ but, it had a few CPU issues. CPU usage increases when a significant amount of CPU time is spent in garbage collection. Heap is the memory that is used to allocate memory dynamically as opposed to the stack memory which is used to store the local variables. Local memory is quite automatic and local variables are allocated automatically. An increased allocation rate of objects on the managed heap causes garbage collection to occur more frequently.\nHere are a few types of Garbage collectors:\nMark \u0026amp; Sweep GC(Tracing GC): A two-phase algorithm that first marks objects that are being referenced as “alive” and in the next phase frees the memory of objects that are not alive. JVM, C#, Ruby, JavaScript, and Golang employ this approach. JavaScript engines like V8 use a Mark \u0026amp; Sweep GC along with Reference counting GC to complement it. This kind of GC is also available for C \u0026amp; C++ as an external library.\nReference counting GC: Every object gets a reference count which is incremented or decremented as references to it change. Garbage is collected when the count becomes zero. This is not preferred as it cannot handle cyclic references. PHP, Perl, and Python use this kind of GC with workarounds to overcome cyclic references. This type of GC can be enabled for C++ as well.\nAutomatic Reference Counting(ARC): Similar to Reference counting GC but instead of running a runtime process at a specific interval the retain and release instructions are inserted into the compiled code at compile-time and when an object\u0026rsquo;s reference becomes zero, it is cleared automatically as a part of the code execution. It also cannot handle cyclic references and relies on the developer. ARC is a feature of the Clang compiler and provides ARC for Objective C \u0026amp; Swift.\nResource Acquisition is Initialization (RAII): Objects and variables are scoped, and an object’s memory allocation is tied to its lifetime, which is from construction until destruction. It was introduced in C++ and is also used by Ada and Rust.\nRust Rust is a general-purpose systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. It is a multi-paradigm language that supports imperative, functional, and object-oriented programming. Rust is not only used to create low-level systems software such as operating systems, device drivers, and embedded software, but also used to create high-level applications such as web servers, command-line tools, and graphical user interfaces.\nRust builds on RAII( Resource Acquisition is Initialization) to provide automatic memory management. RAII is a programming technique that uses the lifetime of an object to manage the lifetime of its resources. In Rust, the compiler ensures that the memory is freed as soon as the object goes out of scope. This is achieved by the use of smart pointers. Rust implements borrow checking and ownership rules to ensure that memory is freed as soon as the object goes out of scope. Additionally, Rust also provides a garbage collector that can be used to free memory when the object goes out of scope.\nOwnership and Borrowing\n#[derive(Debug)] struct Employee { id : i32 } fn main() { let a = Employee{id: 43} ; let b = a ; // println!(\u0026#34;{:?}\u0026#34;, a) ; // error: borrow of moved value: `a` let c= a ; // println!(\u0026#34;{:?}\u0026#34;, a) ; // error: borrow of moved value: `a` } RAII\nfn main() { let foo = \u0026#34;value\u0026#34;; // owner is foo and is valid within this method // bar is not valid here { let bar = \u0026#34;bar value\u0026#34;; // owner is bar and is valid //within this block scope println!(\u0026#34;value of bar is {}\u0026#34;, bar); // bar is valid //here println!(\u0026#34;value of foo is {}\u0026#34;, foo); // foo is valid //here } println!(\u0026#34;value of foo is {}\u0026#34;, foo); // foo is valid here println!(\u0026#34;value of bar is {}\u0026#34;, bar); // bar is not valid //here as its out of scope } Rust \u0026gt; C++ ? C++ is a high-performance, general-purpose programming language that has been widely used for decades. It is known for its flexibility and ability to handle low-level tasks, making it a popular choice for systems programming and game development. C++ also has a large and active community, which means that there are many libraries and resources available for developers to use. Rust, on the other hand, is a relatively new programming language that was first released in 2010. It is designed to be a safe and concurrent language, with a strong focus on preventing common programming errors such as null pointer dereferences and buffer overflows.\nComing back to our questions that we were pondering upon earlier, now we get that compiled languages are preferred over interpreted languages as they are much faster and hence C++/ Go are preferred over Python/JavaScript. While C++ is extremely fast, it is also prone to memory leaks. Other languages such as Rust and Go offer better automatic memory management. Go implements a garbage collector which has a CPU usage overhead while Rust builds over RAII and implements borrow checking and ownership rules to ensure that memory is freed as soon as the object goes out of scope. Rust also provides a garbage collector that can be used to free memory when the object goes out of scope.\nWill rust replace C++ anytime soon? No. Rust is a relatively new language and is still in its early stages of development. It is not yet widely used in production, and there are still many features that are missing. However, it is gaining popularity and is being used in many large projects, such as Firefox and Servo. C++ has been widely used for decades and has a vast amount of legacy code, making it difficult for Rust to replace it. C++ has a much larger community and ecosystem, with a wealth of libraries, tools, and resources, making it easier for developers to find help and resources. Rust\u0026rsquo;s tooling is still evolving and may not be as mature or widely used as C++.\n","permalink":"https://anubhavp.dev/blog/posts/pages/rust/","summary":"Rust is a multi-paradigm systems programming language created to ensure high performance similar to that offered by C and C++, but with emphasis on code safety, the lack of which is probably why C and C++ are painful to deal with. It accomplishes memory safety without using a dedicated garbage collector. Rust is also an ahead-of-time compiled language, which means that you can compile a rust program, give it to someone else, and they can run it even without having Rust installed.","title":"Rust: The next C++ ?"},{"content":" NOTE: This blog post is taken from injuly\u0026rsquo;s website\nTry drawing something on the first canvas, and watch two sets of mechanical alien arms retrace your sketch:\nOnce you\u0026rsquo;re done with this introduction to Fourier analysis, you\u0026rsquo;ll be capable of making this (and a lot more) yourself.\nThe satisfying animation is made possible by the subject of this post - an infinite sum called the Fourier series. The formula is short, and with some effort, you can memorize it. However, I implore you to understand where the series comes from, and build deeper intuition for it.\nTo keep you from clicking off this page, I\u0026rsquo;ll defer the proof and origin of this equation to the second half, and thread some interactive animations through the body of this write-up.\nAdding functions Surely, you\u0026rsquo;re familiar with the addition of numbers, vectors and matrices. Adding functions is not so different. The addition of two functions \\(f\\) and \\(g\\) at input \\(x\\) is simply \\(f(x) + g(x)\\).\nPut more formally - \\((f + g)(x) = f(x) + g(x)\\).\nLet\u0026rsquo;s visualize this by taking an example. Assume f is \\(2sin(x)\\) and g is \\(cos(2x)\\).\nTheir sum then, can be given by a function - \\(h(x) = 2sin(x) + cos(2x)\\).\nThe graph below plots \\(f\\) and \\(g\\) in shades of gray, and their sum, \\(h\\), in red.\nNote how in some places, the values of \\(f\\) and \\(g\\) are both positive, and their sum is therefore a larger positive number, while in other places, \\(f\\) and \\(g\\) have opposite signs and their values cancel out to a smaller number.\nThrough the lens of physics, you could look at the functions as two electromagnetic waves, or just visible light rays oscillating in the domain of time. When two such waves overlap with each other in space, they\u0026rsquo;re said to be in superposition. The superposition of two waves results in the sum of both waves.\nWhen two points in a wave supplement each other to result in a higher amplitude (the y-value), their interaction is termed \u0026ldquo;constructive interference\u0026rdquo;. When they cancel each other out, it\u0026rsquo;s called \u0026ldquo;destructive interference\u0026rdquo;.\nGo through the last two paragraphs again, and try to digest this idea. Now, imagine if we had to work our way backwards. Say we are given a list containing the (x, y) coordinates of all points along the curve of \\(h\\), where \\(x\\) is time and \\(y\\) is the corresponding output of \\(h\\) at that point in time. We have to come up with two simpler periodic functions that sum up to \\(h\\).\nThis is exactly what the Fourier series does.\nThere are several ways to interpret interference in the real world. If \\(f\\) and \\(g\\) were sound waves, their constructive interference would make loud noise, while the destructive interference would produce a quieter sound. If they were light waves instead, their constructive interference would reveal bright spots on a reflective surface, and destructive would look like dim patches.\nApplications of the Fourier series spill into almost every domain - signal processing, image compression, shape recognition, analog transmission, noise cancellation, studying thermodynamic systems and fitting equations to datasets.\nFrom this wide array of applications, We show our interest in the science of tracing ugly sketches.\nDecomposing periodic functions. Imagine you had a machine that could scan any food item and display its recipe. Fourier series does exactly that, except for mathematical functions.\nThe Fourier series of any periodic function \\(f(x)\\) with a frequency of \\(\\omega_0\\) is described as:\n$$ f(x) = a_0/2 + \\sum_{n=1}^{\\infty}b_n sin(n\\omega_0x) + \\sum_{n=1}^{\\infty}a_n cos(n\\omega_0x) $$ Meaning that for every periodic function \\(f\\), there exists a set of coefficients \\(a\\) and \\(b\\), such that \\(f(x)\\) can be expressed as an infinite sum of sine and cosine terms of increasing frequencies where the \\(nth\\) sine term has a coefficient of \\(b_n\\) and the \\(nth\\) cosine term has a coefficient of \\(a_n\\). The values of these coefficients are given by the following formulae:\n$$ a_n = \\int_0^T{f(x)cos(nw_0x)} $$\n$$ b_n = \\int_0^T{f(x)sin(nw_0x)} $$\nThe interval of integration, \\(T\\), is the fundamental period of the function. \\(T\\) and \\(\\omega_0\\) are related by this equation:\n$$ \\omega_0 = 2\\pi/T $$\nIf that was too wordy and made little sense to you, that\u0026rsquo;s okay. We\u0026rsquo;ll prove this equation later in the post. Until then, an example will help understand this better.\nConsider the square wave - a periodic signal that alternates between 1 and -1 depending on its input. Formally, it is described like so:\n$$ f(t) = 4 \\lfloor{t}\\rfloor - 2\\lfloor2t\\rfloor + 1 $$\nHere\u0026rsquo;s how it looks when graphed out:\nIf we use the first few terms from \\(f\\)\u0026rsquo;s Fourier series, we can closely approximate the behavior of this function. In the following graph, the gray curve represents the the square wave and the red curve represents our approximation of it. You can play with the slider to alter the number of terms we take from the series and see how that changes our approximation.\nClearly, our approximation improves as we take more terms from the series. The Fourier series can be proven to converge. This means that if we take an infinite number of terms from the series, we can get the exact value of \\(f(x)\\) for any \\(x\\).\nOf course, it is not possible to add up infinite terms in computers. Instead, we decide upon a fixed number of terms that approximate our function well enough for most practical purposes.\nWhenever I say \u0026ldquo;Fourier series of a function\u0026rdquo;, I mean a series of simple periodic functions that can be added at any given input to approximate the output of the original function at the same input. For the remainder of this post our goal with Fourier series is to approximate periodic functions with sums of simpler sine/cosine functions.\nDrawing with the Fourier series If you wish to understand how the Fourier series works before seeing it in action, you can skip this section and read ahead to the proof, then come back here.\nSo, How do we go from decomposing time domain functions to recreating sketches?\nImagine you\u0026rsquo;re drawing a sketch on a square sheet of paper. You are to draw your sketch, start to finish, without lifting the nib of your pen from the paper\u0026rsquo;s surface. In other words, your sketch must be continuous with no \u0026ldquo;breaks\u0026rdquo; in between.\nAssume also that the bottom-left corner of the sheet is its origin. Once you start drawing, I can delineate the position of the pen\u0026rsquo;s tip using a pair of coordinates \\((x, y)\\) at any given point in time.\nMuch like a cartesian plane, the \\(x\\) coordinate represents the horizontal distance from the origin, and \\(y\\) the vertical. Both the x and y coordinates change as the pen moves on the sheet\u0026rsquo;s surface. Meaning, the position of the x-coordinate of your pen\u0026rsquo;s tip can be written as a function of time. Say you draw this figure:\nIf we plot the x and y-coordinates independently as functions of time, they\u0026rsquo;ll form curves that look like this:\nThe blue curve represents the values of x-coordinates of your sketch. The vertical axis represents the x-value, and the horizontal axis represents time. Similarly, the red curve plots the y-coordinates.\nBoth these curves can be viewed as functions of time. The blue curve represents a function \\(x(t)\\) that returns the x-position of the pen\u0026rsquo;s tip at time \\(t\\), Similarly, the red curve is a function \\(y(t)\\) which the same for its y-position. For each of these functions, we can find a Fourier series that approximates it.\nLet \\(f_x(t)\\) and \\(f_y(t)\\) be the Fourier approximations for \\(x(t)\\) and \\(y(t)\\) respectively. Then recreating the sketch requires computing the values returned by f_t and y_t over a range of values of t. then pairing them into (x, y) coordinates and connecting the coordinates with lines. Here is some pseudo-typescript code that mimics this logic:\n// The \u0026#34;dt\u0026#34; is our time step. // In the real world, a line is an infinitely long series of points. // In computers, we take a \u0026#34;snapshot\u0026#34; of the pen\u0026#39;s position // every dt seconds and join these positions with straight lines to // trace the curve. Smaller values of dt require more computation, // and yield better results. const dt = 0.01; const f_x = fourier_series(x); // type of x is (t: number) =\u0026gt; number const f_y = fourier_series(y); // type of y is (t: number) =\u0026gt; number let prev_point = [f_x(0), f_y(0)]; for (let t = 0.01; t \u0026lt; 1; t += dt) { const current_point = [f_x(t), f_y(t)]; draw_line(prev_point, current_point); prev_point = current_point; } The approximation generated by this method is shown below. Just as before, you can play with the slider to adjust the number of terms used in approximation of the sketch.\nKeep in mind that f_x and f_y are really just sums of simpler sine/cosine functions, calculated using Fourier\u0026rsquo;s formulae.\nYou may be wondering - the functions \\(x(t)\\) and \\(y(t)\\) aren\u0026rsquo;t periodic, how come we can still decompose them into sine/cosine sums? One trick is to set the period to infinity, and compute the series at this limit.\nIn my code, I just set the period to 1 time unit, and assume that the pen just retraces the drawing again and again. Meaning that \\(x(t + 1) = x(0)\\). This makes the math a lot easier, and certainly doesn\u0026rsquo;t make a difference in the outcome.\nTo be more clear, when the sketch starts, the time is assumed to be 0, and when it ends, the time is assumed to be 1 second. Every time point in between is scaled accordingly. This is not necessary of course, you could set the time period to however long it took to draw the first sketch, if that makes things simpler for you.\nEpicycles The final caveat are the epicycles. It is easy to just plot the values returned by \\(f_x\\) and \\(f_y\\) on the cartesian plane. But how do we animate this using revolving circles?\nIf you\u0026rsquo;ve followed the contents of this article so far, you already know how to recreate sketches. To animate them, you need to understand The polar coordinate system.\nYou can read the wikipedia article, or this article to build some intuition for conversion between cartesian and polar coordinates.\nIn the polar coordinate system, a periodic function with period \\(T\\) is a vector that rotates around the origin, and completes one full rotation around itself every \\(T\\) time units. Look at the graph of \\(sin(t)\\) in Polar form, for example:\nNote how the y-coordinates of the vector\u0026rsquo;s tip traces out a regular sine wave. You can just as easily plot any periodic function in the polar coordinate system. To add two periodic functions together, take one rotating vector and center it on the tip of the another rotating vector. The end result is shown below. The following animation shows 3 rotating vectors added together, each representing a periodic function:\nTo convert a sketch to an epicycle animation then, all we need is to convert a term in the Fourier series from cartesian to polar coordinates. Once we have that, we can add up the terms like in the animation above, and figure out the x and y-coordinates using two sets of epicycles, each representing the Fourier approximation for \\(x(t)\\) or \\(y(t)\\).\nTo do this conversion, we can use the polar form of the Fourier series. Precisely, these are the steps you need to follow:\nRepresent the sketch as a list of points drawn over a period of time. Convert the list of points into a two separate lists, one containing the x-coordinates of the sketch, and other the y. Convert each list into a function (I use this simple helper). Now, you have the \\(x(t)\\) and \\(y(t)\\). For each function, find its Fourier series coefficients. Here is how I do it. For each function, convert the Fourier series coefficients into a set of polar functions. Using a time step of dt, find the final x and y positions of our approximation, and draw them on a canvas. If you do everything correctly, you should get something like this:\nThere is a more novel approach to retracing sketches that involves using only one set of epicycles. It uses the complex Fourier Series, and is also fewer lines of code. When you\u0026rsquo;re new to this concept however, it may throw you off balance, especially if you\u0026rsquo;re not familiar with imaginary numbers and the Argand plane.\nProof When I set out to find an \u0026ldquo;intuitive\u0026rdquo; proof for the Fourier series, all I saw were proofs that begin by stating the equation, and then proving it by finding the coefficients \\(a_n\\) and \\(b_n\\) using integrals. But where did the equation come from?\nDid God whisper it to Joseph Fourier in his dreams?\nDid he just happen to run into it by chance?\nSurprisingly, the answer is \u0026ldquo;yes\u0026rdquo;. Of course, he had an unparalleled instinct for math that he whetted with years of practice and research. There has to be a certain train of thought that he boarded to arrive at this revelation, that any periodic signal can be represented as a sum of simpler harmonics. But that line of thinking was never publicized, and as you\u0026rsquo;ll see in the next section, there have been people who\u0026rsquo;ve thought of this even before Fourier himself did!\nThe important part is that Fourier asked a question that was mocked as stupid and bizarre until he presented a proof. And that proof does in fact begin by stating the following hypothesis:\n$$ f_o(t) = \\sum_{n = 0}^\\infty{b_nsin(n\\omega_0t)} $$\nHere, \\(f_o\\) is an odd function with a fundamental period of \\(w_0\\). If we can derive a value for \\(b_n\\) from this equation, we can be convinced that any odd function can be represented as a sum of sinusoids.\nNow, consider an even function \\(f_e\\) with a period of \\(w_0\\):\n$$ f_e(t) = \\sum_{n=0}^{\\infty}a_n cos(n w_0 t) $$\nIf we can derive a value for \\(a_n\\) from this equation, we can be convinced that any even function can be represented as a sum of co-sinusoids.\nWhen you combine these two equations with the idea that any periodic function can be represented as a sum of odd and an even function, you get:\n$$ f_o(t) + f_e(t) = \\sum_{n = 0}^\\infty{b_nsin(n\\omega_0t)} + \\sum_{n=0}^{\\infty}a_n cos(n w_0 t) $$\nWe can turn the order of this proof, and first say that given any function \\(f(t)\\), we can find its odd and even parts using the odd-even decomposition rule. Then, we can represent the odd part as a sum of sinusoids, and the even part as a sum of co-sinusoids.\nNow, all that\u0026rsquo;s left is to derive the values for \\(a_n\\) and \\(b_n\\) using the two equations stated above. This is where I save myself the trouble of writing more LaTeX, and defer you to this excellent proof by professors from Swarthmore college. I know I said I\u0026rsquo;d walk you through the proof, but I can\u0026rsquo;t do a better job of it than the electronics professors at Swarthmore did already. I\u0026rsquo;d hate to repeat their work and not give credit. If you follow the page I linked, you\u0026rsquo;ll realize that the proof only uses basic calculus and trigonometric identities taught in high school.\nOrigins You\u0026rsquo;ll be surprised to learn that the idea behind the series predates Fourier himself.\n2 centuries before Fourier, Carl Friedrich Gauss created several algorithms to aid his study of astronomy. He was one of the many applied mathematicians who wanted to predict the position of Ceres in the night sky. One of the algorithms he discovered in this quest, was the Fast Fourier Transform - a function that is very closely related with the Fourier Series. However, he never published his work because he believed his method to be an unimportant detail in his achievement of estimating Ceres\u0026rsquo; position.\nIn the 1700s, Euler had found applications for decomposing periodic functions with Fourier Series.\nHalf a century before Fourier, Bernoulli was studying the motion of a string. He proposed the idea that periodic functions can be represented as sums of harmonics. Nobody at the time believed this to be a general method, and his ideas were left unexplored.\nThings changed in 1807, when a French math wizard named Joseph Fourier found himself studying the heat equation in a metal plate. In his search for a solution, he sought to ask a seemingly absurd question:\nCan we represent any periodic function as a sum of simple sine and cosine functions?\nPrecisely, he sought to represent any periodic function \\(f(x)\\) with a frequency of \\(\\omega_0\\) , in the following form:\n$$ f(x) = (a_0 + a_1 cos(\\omega_0 t) + a_2 cos(2\\omega_0 t) + ... + a_n cos(n\\omega_0t)) + (b_1 sin(\\omega_0 t) + b_1 sin(2\\omega_0 t) + ... + b_n sin(n\\omega_0t) $$ Revered mathematicians of the time, including Langrange and Laplace, rejected this idea as informal and hand-wavy. The panel evaluating his findings said:\n\u0026ldquo;The manner in which the author arrives at these equations is not exempt of difficulties and\u0026hellip;his analysis to integrate them still leaves something to be desired on the score of generality and even rigour.\u0026rdquo; Perhaps this was because of a lack of reasoning as to why one should even begin to think of periodic functions this way.\nIt\u0026rsquo;s not unheard of mathematical ideas to sprout into existence out of seemingly ridiculous places. Ramanujan attributed some of his major findings to God, and dipped at the age of 32.\nAfter the Fourier Series was accepted by the scientific populace, it spawned a new field of research, called Fourier analysis. Developments in this field found everyday use in almost every science.\nApplications By this point, you know enough about Fourier analysis to delve deeper into it yourself. It would be a shame to blunt the edge of theory by not applying it in practice.\nHere a few things you could do:\nImplement noise reduction in sounds. Sharpen images with denoising. Write a JPEG encoder/decoder. Fit an elephant Write basic shape recognizers. Resources and further reading 3b1b - But what is a Fourier series?. Swarthmore college - The fourier series. Jez Swanson - An interactive introduction to the fourier transform. Tony Rosler - myFourierEpicycles ","permalink":"https://anubhavp.dev/blog/posts/pages/fourier/","summary":"NOTE: This blog post is taken from injuly\u0026rsquo;s website\nTry drawing something on the first canvas, and watch two sets of mechanical alien arms retrace your sketch:\nOnce you\u0026rsquo;re done with this introduction to Fourier analysis, you\u0026rsquo;ll be capable of making this (and a lot more) yourself.\nThe satisfying animation is made possible by the subject of this post - an infinite sum called the Fourier series. The formula is short, and with some effort, you can memorize it.","title":"Fourier Series"},{"content":"I am working with Squbix Digital to build a decentralized, secure and scalable solution using blockchain technology for Sovereign Wallet. The solution is to build a platform to exchange digital assets such as cryptocurrencies and digital currencies across a country/ organization and a cross-border payments system. Here is the metamui whitepaper and here are some of the things that I couldn\u0026rsquo;t digest well.\nMetablockchain-core Metablockchain: The blockchain that lets you regulate digital currencies and cryptocurrencies across the nation. The platform is built on Polkadot protocol that has significantly better runtime efficiency, is cost-effective, and supports parallel faster transactions when compared to other traditional blockchains. The Polkadot protocol is designed to allow unrelated blockchains to securely talk to each other, so that value or data can flow between, say, the Ethereum and Bitcoin blockchains without any intermediary. It’s also designed to be speedy and scalable, via the use of many parallel blockchains (or “parachains”) that take much of the processing demand off of the main blockchain. The Polkadot network can process more than 1,000 transactions per second, compared to about 7 for Bitcoin and 30 for Ethereum. As the network grows and more parachains are added, Polkadot should get even faster, with speeds that could hit a million transactions per second.\nRobust, decentralized, and secure? The product is built in such a way that a country/ government/central banking authority can adopt this platform and make it run parallel with the currently existing infrastructure. Users can send and receive money across the country and it takes significantly less time to handle international transactions. It seems great, an easier way to handle transactions, without having to pay taxes to the government for making international exchanges! But the reality may not be as exciting.\nMetaMUI is claimed to solve the blockchain trilemma by having a hybrid architecture. For micropayment, we used centralized architecture to achieve high performance and high security. For higher volume payment, we used decentralized architecture to achieve high security and decentralization.\nThe current infrastructure is easy to use but is not as secure as claimed. The primary goal of the infrastructure is to make it easier for users to send and receive (traditional banking) money across the country and, it is not secure because it is not decentralized, and well-developed . Introducing a blockchain as a means of a runtime to carry out transactions as opposed to a traditional banking system is to make sure that all the transactions are handled in a decentralized manner and anyone when wanted, can query and view the source, and all the states of the transactions but it is not the case here.\nIssues with the current infrastructure The usage of a private blockchain.\nThe banks are responsible for running validator nodes that run on the private blockchain and are responsible for validating the transactions and the states of the system. The claims as said were to improve security and transparency but this approach opposes the purpose of the claims. A private blockchain to carry out transactions makes it a kind of database and a runtime that is not public and not accessible to anyone. The banks are servers and the blockchains act as databases. The clients are the users. Seem familiar? This is a client-server architecture with a blockchain running as a database.\nBank Node is a publisher of anonymous tokenized cash. Users can choose Bank Node service providers and have a token contract to issue digital cash. Based on the contract, it can be a debit card or credit card type. When the user pays the merchant with digital cash, the merchant can claim the digital currency to the issuing Bank Node. \u0026ldquo;The performance of this payment process should be equal to or better than normal credit card payments.\u0026rdquo;\nFor high-volume money transfer, MetaMUI utilizes a normal blockchain consensus protocol. All Bank Nodes are involved in the consensus of multiple digital currencies. Since this a transfer between identities, it is a kind of digital cheque payment. Also since we are using blockchain consensus to do so instead of a centralized server for cheque clearance, this is a decentralized cheque system. This payment process is slower than the conventional credit card payment but it is much faster and costs less than an account-based international bank transfer.\nBuilding a platform for carrying out transactions is perfectly okay but introducing blockchains as a means of a just database doesn\u0026rsquo;t make sense. It feels like a gimmick, a buzzword to secure seed \u0026amp; money from investors. Also, there is nothing wrong with a client-server architecture but the speed of current infrastructure relies on implementing a blockchain as a runtime for transactions, which, as always, is slow. Blockchains are supposed to be secure and transparent but they are not efficient and fast. The transaction data when accessible publicly make the network secure, which it is not, here. Whereas a more traditional client-server architecture is equally secure and more efficient. Look at the current banking and payment gateway scenario in India. UPI payments, net banking, and debit card payments, are all carried out in a secure environment and are blazing fast.\nA blockchain-style data store is secure but it is not efficient in terms of computation, communication, and data point of view.\nThe Consensus mechanism\nConsesnus Protocol MetaMUI’s consensus protocol is a combination of PBFT(Practical Byzantine Fault Tolerance) and PoS(Proof of Stake). Only Bank Nodes participate in the consensus of built-in blockchains. Bank Node can be a block proposer and endorser of both built-in blockchains and all digital currency blockchains. The mobile node can participate in the consensus of newly created digital currencies as an endorser. In the case of digital currency consensus, only a Bank Node can be a leader or the block proposer.\nBank nodes have the authority to govern, validate transactions and decide the fate of the entire system, which makes the bank a central authority here. This gives authority to the bank nodes to validate any transactions. The bank may decide to invalidate valid transactions or validate invalid transactions and no one would know cause it would be there \u0026ldquo;on the blockchain\u0026rdquo;. (Not saying that this would be done, because a banking sector obviously wouldn\u0026rsquo;t carry out fraudulent transactions.) This does raise a question about the prorposed solution that claims to have solved the blockchain trilemma.\nThe leader node also acts as a serializer to serialize transactions. The leader node receives block rewards and transaction fees. Endorser also receives the endorsing rewards when the node’s endorsement is included in the majority vote.\nThe endorser and leader nodes receive rewards based on the node’s endorsement. The endorser node receives the endorsement rewards when the node’s endorsement is included in the majority vote. The leader node receives the block rewards when the node’s block is included in the majority vote. How does a network with an nPOS consensus protocol pay or reward nodes if there are no gas fees involved?\nACB (Algorithmic central bank)\nThe current platform runs a single and private blockchain without any overhead of the AI mechanism that will fuel the infrastructure. Implementing the Algorithmic Central Bank can be a key player in the industry. The current platform is inefficient when run using a single private blockchain and no centralized banking establishment to control inflation and deflation. The product can be improved when the existing mechanism as proposed in the whitepaper come to play. The current platform might not be a very good solution for the industry unless the stated propositions come to play.\nMetaMUI is just the starting point. We suggested fundamental solutions for Algorithmic Central Bank and a decentralized, but expandable ecosystem based on mobile nodes. But we believe the current development of artificial intelligence technologies such as deep learning and reinforcement learning will be the key game changers of the blockchain platform. MetaMUI was designed to take care of these technologies. In near future, we can see the powerful coordination of more flexibilities based on artificial intelligence and robustness/ stability for transactions based on the blockchain platform.\nThe digitalization of currency opens up new opportunities for digitalized monetary decision-making. Bank node is an early form of Algorithmic Central Bank that makes monetary decisions based on financial big data. It is possible to apply a federated learning algorithm at the central bank node and collect and learn a decentralized model on many mobile nodes.\nIdeological challenges MetaMUI wallet also lets you regulate digital currencies and crypto-currencies across the world and carry out transactions without having to pay conversion fees. This current implementation of the ideology may become an issue because of the following reasons:\nGovernments of countries do not generally allow cryptocurrencies to be legal tender. There are two countries as of now that currently allow cryptocurrencies to be traded and accepted as legal tender and both of them are not the most developed or developing nations in the world. Targeting these countries to sell the platform might not be wise.\nGovernments usually have a means of regulating easier banking methods and exchange methods. Let us take the example of India. India doesn\u0026rsquo;t allow cryptocurrencies to be legal tender. Digital payments are very popular and online payments being carried out in India follow traditional banking and government norms and are very fast. I don\u0026rsquo;t think anyone in the current generation nowadays goes to the bank to deposit or withdraw money. Let us take another example of the UID system followed in India, Adhaar system. The system is encrypted using military-grade encryption. The system is very secure and the government is very responsible for the security of the system. The current implementation of encryption used at MetaMUI Wallet is SHA-256 which although a very secure algorithm would seem like legacy software for the Indian government to integrate and work with. The task is tedious and unnecessary.\nThere seems no solid revolutionary reason for a bank/government to introduce a new platform to run which regulates and carries out transactions and exchanges for free. Excellent existing platforms are already available and our infrastructure is not a new platform. (Paytm, Gpay, Paypal, CoinDCX etc.)\nConversion fees are a means of generating tax for a government. International exchanges or cryptocurrency exchanges are a means of generating tax for a government. When you convert INR to USD or vice versa, you are generating tax for the government. Current conversion from ETH, BTC to INR is a very low fee but there does exist a fee.\nMetaMUI Network is an Internet-based cross-border payment network. In MetaMUI Network, each user’s DID is a universal accounting address that user can send or receive digital currencies. Utilizing collateral asset feature and meta-blockchain feature of MetaMUI Blockchain, it is possible to dynamically create meta-coin on the fly to facilitate cross-border payment between the currencies those are not on the MetaMUI Network. Similar to the stable coin issuance, central bank or commercial bank of each country can create stable meta-coin on the MetaMUI Network and perform international fund transfer\nThe platform introduced doesn\u0026rsquo;t have gas fees. Gas fees are the fees in a blockchain that you need to pay to make a transaction or carry out a smart contract. A miner validates your transaction by spending its computation power and in return is awarded the gas money. Gas fees are a means of generating revenue for a miner, but having no gas fees in a private blockchain implies that the bank and the infrastructure have to spend money on electricity and computing resources to validate transactions. It doesn\u0026rsquo;t make sense to have a platform that makes you spend money on electricity and computing resources just to validate transactions.\nWhen users are trading digital stocks or assets in a peer-to-peer way, MetaMUI provides an atomic swap of digital stock and digital currency. Since digital stock is bind to the user’s identity, ownership transfer notification and tax payment can happen at the same time as the stock trade. This eliminates the need for separate shareholder registration, issuance of shareholder certificates, tax reports to the government, and tax payments.\nLet us again take the example of India. Cryptocurrencies when made legal in India would have a 30% conversion fee, you\u0026rsquo;d have to pay a 30% tax to the government for converting the cryptocurrency. It wouldn\u0026rsquo;t make sense for India to allow the platform to run without a conversion fee. Also, there are a lot of other, well-established platforms playing in the same field and pitching and hitting hard in these areas. (CoinDCX, Coinbase, etc)\nPresent operating scenario in foreign exchange platforms.\nCheaper, faster, and efficient cross-border payments are the need of the hour in today’s digital world. The MetaMUI Network is designed to host multiple blockchains concurrently. Each of these blockchains can run independently of each other and communicate (transact) with each other. The currency exchange is made possible through atomic swaps and multi-currency transfer is possible with an exchange service provider (Master Node) making it excellent for direct sovereign currency to sovereign currency cross-border payments\nThe existing exchange platforms are extremely secure, well-established, and highly efficient. The working and operation of these platforms are governed by international laws. The current implementation of MetaMUI Wallet doesn\u0026rsquo;t include any gas fees for transactions. It\u0026rsquo;d either have to tie up with an exchange platform or would have to come up with some other way to convince a country to let it handle all of its transactions. Either way, it would be both cost ineffective solutions. With private blockchains and 0 gas fees, MetaMUI Wallet will be having a hard time trying to carry out free transactions across the globe. The organization, at first, would have to pay for the mining and electricity and on top of that would have to pay the cross-border payment fees too.\nA better direction There might exist better, more efficient solutions to the above problems but two of them may have these similar approaches:\nIntroduce a public blockchain This solves the problem of spending money on validating transactions. Miners can validate transactions and the government/ bank can verify the transactions. This would be a huge bump in security, transparency, and cost efficiency.\nIt still doesn\u0026rsquo;t solve the problem of introducing a new platform just to do this. The tax play still becomes an issue here. How does the platform plan on managing taxes? Why would a bank allow a platform to run which would not benefit it in any manner? The government levies taxes to exchange international currencies. Why would it stop doing that? Even if it is allowed, how would it compete with other platforms working towards a similar strategy?\nFollowing traditional client-server architecture using a distributed database This would solve the problem of efficiency. Traditional architectures have been here for a very long time and a lot of research has been done on optimizing the existing infrastructure. Horizontal slicing, vertical slicing, and many other optimization techniques may be used to improve the efficiency of the platform. The platform would be faster, equally secure, and more efficient.\nThe issue with this approach is the question that what problem is it really trying to solve. Don\u0026rsquo;t there exist platforms that are already doing everything this infrastructure is trying to solve? How would it be able to compete with the existing giants? Isn\u0026rsquo;t the solution building a redundant, regular, exchange banking platform that the world has no less of? How would the platform differentiate itself? What is MVP, the USP of the platform? If it decides to work together with the government, what ensures that other existing strong infrastructures do not also decide to do this and do it better?\nImproving the current infrastructure The approaches may be justified once some of the important issues are addressed. Other than the mentioned problems, a lot of other factors need to pitch in to improve and make the platform more a feasible good product to be sold. The product being built is excellent, no doubt. The deep learning models in the ACB mechanism, the tech being used, the next generation Polkadot blockchains which are much, much faster (1000 transactions per second as compared to 7-10 transactions in traditional blockchain networks) and allow a huge on queries in a much faster time, the faster and more efficient transaction mechanisms, interoperability, the economic scalability, user-driven governance, the forkless upgrades, and the claimed security and transparency, are a step in the right direction, but there are grave issues those still need to be discussed before the product is introduced and launched.\nRef: Whitepaper\n","permalink":"https://anubhavp.dev/blog/posts/pages/metamuiwallet/","summary":"I am working with Squbix Digital to build a decentralized, secure and scalable solution using blockchain technology for Sovereign Wallet. The solution is to build a platform to exchange digital assets such as cryptocurrencies and digital currencies across a country/ organization and a cross-border payments system. Here is the metamui whitepaper and here are some of the things that I couldn\u0026rsquo;t digest well.\nMetablockchain-core Metablockchain: The blockchain that lets you regulate digital currencies and cryptocurrencies across the nation.","title":"Decentralization in MetaMUI Wallet: A Case Study"},{"content":"Zuzu is a static site generator that takes in markdown files and render htmls pages. This blog, for example, has been written using this generator. This enables noobs like me to write blogs without having to learn a lot of code! It is a very simple and easy to use generator. All you need to do is to write a markdown file and it will be rendered as a page ;) You can create a new page by creating a new markdown file.\nHow does it work? Zuzu parses the markdown file using javascript and renders it as html documents. It then saves the html files in the public folder. The public folder, with index.html file, is the final output of the generator and this can be deployed and hosted in various platforms. This particular blog has been deployed on Github Pages.\n1. Create a markdown file # This is a title\rThis is a paragraph\rThis is another paragraph\rThis is a list:\r* Item 1\r* Item 2\r* Item 3\rThis is a code block:\r```\rprint(\u0026quot;Hello World\u0026quot;)\r```\rThis is a table:\r| Column 1 | Column 2 | Column 3 |\r| -------- | -------- | -------- |\r| 1 | 2 | 3 |\r| 4 | 5 | 6 |\r| 7 | 8 | 9 |\rThis is a link: [zuzu](https://anubhavp.dev/blog/zuzu.html)\r2. Run the generator and find your blog Run npm run generate in the console. You\u0026rsquo;ll now see the blog in the public folder! Run the index.html file in your browser to see your blog. You may now deploy your site to a server.\nThe Static Site Generator 1. Libraries used MarkdownIt Markdown parser done right. MarkdownItAnchor Header anchors for markdown-it. Glob \u0026ldquo;Globs\u0026rdquo; are the patterns you type when you do stuff like ls .js on the command line, or put build/ in a .gitignore file. Gray-Matter Parse front-matter from a string or file. Mkdirp Create Dirs if they do not exist. 2. Workflow This is the code for the generator.js. The code works in the following way:\nfs.readfile() from fs reads all the files from the said directory and stores then in filename using glob. It is a glob that matches all the files in the directory. The file system module allows you to work with the file system on your computer. gray-matter helps extracting front matter from the a string or file. Converts a string with front-matter, like this: title: Hello\rslug: home\r---\r\u0026lt;h1\u0026gt;Hello world!\u0026lt;/h1\u0026gt; Into an object like this:\n{\rcontent: '\u0026lt;h1\u0026gt;Hello world!\u0026lt;/h1\u0026gt;',\rdata: { title: 'Hello', slug: 'home' }\r}\rIt then extracts the front matter and stores it in data. It then stores the content in content and returns the filename to the main() function. It then repeats the process for all the files in the directory.\nThe main() function then takes in one filename at a time and then parses it through markdownit( ,{markdownitanchor}). markdownit parses the file and converts the markdown content into HTML files. It then creates a html file and writes the parsed content into it. It then saves the html file in the public folder. This process repeats for all the files in the directory.\nThe converted html files are stored in the specified directories then using mkdirp. The index.html file isalready present in the public folder. mkdirp creates the directories if they do not exist.\n3. Generator Code import fs from \u0026#39;fs\u0026#39; import glob from \u0026#39;glob\u0026#39; import matter from \u0026#39;gray-matter\u0026#39; import mkdirp from \u0026#39;mkdirp\u0026#39; import path from \u0026#39;path\u0026#39; import hljs from \u0026#39;highlight.js\u0026#39;; import MarkdownIt from \u0026#39;markdown-it\u0026#39; import markdownItAnchor from \u0026#39;markdown-it-anchor\u0026#39; import string from \u0026#39;string\u0026#39; const slugify = s =\u0026gt; string(s).slugify().toString() const md = MarkdownIt({ html: true, linkify: true, typographer: true, highlight(str, language) { if (language \u0026amp;\u0026amp; hljs.getLanguage(language)) { try { return hljs.highlight(str, { language: language }).value; } catch (err) { console.log(err) } } return null; } }).use(markdownItAnchor, { slugify }); const readFile = (filename) =\u0026gt; { const rawFile = fs.readFileSync(filename, \u0026#39;utf8\u0026#39;) const parsed = matter(rawFile) const html = md.render(parsed.content) return {...parsed, html } } const templatize = (template, { date, title, content, author }) =\u0026gt; template .replace(/\u0026lt;!-- PUBLISH_DATE --\u0026gt;/g, date) .replace(/\u0026lt;!-- TITLE --\u0026gt;/g, title) .replace(/\u0026lt;!-- CONTENT --\u0026gt;/g, content) .replace(/\u0026lt;!-- AUTHOR --\u0026gt;/g, author) const saveFile = (filename, contents) =\u0026gt; { const dir = path.dirname(filename) mkdirp.sync(dir) fs.writeFileSync(filename, contents) } const getOutputFilename = (filename, outPath) =\u0026gt; { const basename = path.basename(filename) const newfilename = basename.substring(0, basename.length - 3) + \u0026#39;.html\u0026#39; const outfile = path.join(outPath, newfilename) return outfile } const processFile = (filename, template, outPath) =\u0026gt; { const file = readFile(filename) const outfilename = getOutputFilename(filename, outPath) const templatized = templatize(template, { date: file.data.date, title: file.data.title, content: file.html, author: file.data.author, }) saveFile(outfilename, templatized) console.log(`📝 ${outfilename}`) } const main = () =\u0026gt; { const srcPath = path.resolve(\u0026#39;content\u0026#39;) const outPath = path.resolve(\u0026#39;public\u0026#39;) const template = fs.readFileSync(\u0026#39;./templates/initial/template.html\u0026#39;, \u0026#39;utf8\u0026#39;) const filenames = glob.sync(srcPath + \u0026#39;/**/*.md\u0026#39;) filenames.forEach((filename) =\u0026gt; { processFile(filename, template, outPath) }) } main() ","permalink":"https://anubhavp.dev/blog/posts/pages/zuzu/","summary":"Zuzu is a static site generator that takes in markdown files and render htmls pages. This blog, for example, has been written using this generator. This enables noobs like me to write blogs without having to learn a lot of code! It is a very simple and easy to use generator. All you need to do is to write a markdown file and it will be rendered as a page ;) You can create a new page by creating a new markdown file.","title":"zuzu: A Static Site Generator (SSG)"},{"content":"During my short stint as a blockchain developer, I\u0026rsquo;ve learned a lot and have met amazing people. While I acknowledge the skill and reverence of some developers in this domain, I still remain uncharmed by the zeal of web3.\nIf you\u0026rsquo;re a blockchain enthusiast reading this, know that I understand where you stand. I\u0026rsquo;ve been in your shoes, and I draw my opinions from personal encounters with the crypto ecosystem. What I ask of you as a peer then, is that you put your tech under a lens of scrutiny and sever any bonds that may develop into religious fanaticism. This is true of all engineering, of course. We cannot improve a technology if we\u0026rsquo;re blind to it\u0026rsquo;s limitations. And we can\u0026rsquo;t perceive limitations unless we are open to critique. Critique such as this one.\nMost engineers who build blockchains and NFT based projects recognise the technical limitations of this technology. Yet they choose to write them off as \u0026ldquo;tradeoffs\u0026rdquo; for web3, or worse, turn a blind eye to them. And then there are the social problems - ones that are so nuanced that they can\u0026rsquo;t be tackled by any number of token standards or consensus algorithms. This post is my attempt at shedding some light on the problems that I\u0026rsquo;m aware of.\nSocial The majority of crypto is shady, even for artists Cryptocurrency is always found in a massive web of controversy, frauds and scams. Show me one successful crypto project that has served a real purpose, and I\u0026rsquo;ll show you 10 that were outed for being scams.\nNFTs claim to be a revolution for artists and creators. But what happens when someone makes an NFT out of stolen art? Owing to a blockchain\u0026rsquo;s immutable nature, the thief now owns the art forever, even if they\u0026rsquo;re found out.\nThe solution that crypto evangelists propose is that artists should mint an NFT out of their art before someone else gets the chance. But this is far from a realistic solution. A creator should not be bothered with signing tokens on a myriad of different markets and blockchains just to avoid being wronged. Why should an artist pay to register an NFT on Flow, Ethereum, Solana, Monero, Tezos and countless other chains under the sun?\nNFT marketplaces are centralised and controlled The willingness to be free from institutional regulation and government censorship is at the nexus of \u0026ldquo;web3\u0026rdquo;. The idea of a government powerless to stop a citizen from owning any digital asset appeals to many. However under this veil of liberation and freedom lies a truth that no crypto-bro will tell you - The very marketplace you view and trade your assets on are centralised and controlled.\nNFT assets can be removed from objkt and opensea, you can be banned from coinbase. Opensea even admits it themselves! If you violate any of the following vague \u0026ldquo;rules\u0026rdquo;, your NFT will be delisted from a supposedly \u0026ldquo;decentralised\u0026rdquo; and \u0026ldquo;uncensorable\u0026rdquo; marketplace.\ninfringe on protected intellectual property, promote suicide or self-harm, incite hate or violence against others, degrade or dox another individual, otherwise violate our terms of service. But what constitutes \u0026ldquo;violence or hate against others\u0026rdquo;? Will I get banned if I make fun of a political figure? Rather, Can I get banned if I make fun of a political figure? Clearly, the answer is yes. The people moderating this website do wield that power. \u0026ldquo;Moderating a decentralised and censor-proof website\u0026rdquo; is an oxymoron, and how the people trading on such platforms fail to realise this eludes me.\nNFTs are\u0026hellip; worthless? In stark contrast with their price tags, the actual value represented by an NFT is surprisingly low. Say you spend all the money you saved for your child\u0026rsquo;s education to buy this rock NFT:\nNow you\u0026rsquo;re pumped with adrenaline, because you own this piece of history. The image is yours, and you claim all rights to its usage and redistribution. This art piece is now valued as if it were a real and tangible rock, there is only one rock and only one owner - you.\nRight? Wrong. The artist still owns the image, and they\u0026rsquo;re entitled to sell it to others, or even make yet another NFT out of it on a different blockchain and sell it there.\nSo if you don\u0026rsquo;t own this rock, what exactly do you possess? The ability to use this on the internet as you please? So do I. I used it just now, to show you what it looks like.\nHad the rock been real, the owner would\u0026rsquo;ve been capable of sculpting it into a showpiece - the exact physical properties of which no one else can have. Or they could use it to assault kids on a street, something noone else could do with the same edge, for there exists only one. If I tried to assault children with a similar rock, I wouldn\u0026rsquo;t be subject to the same acclaim as you. Because my rock and yours have real, physical differences down to the microscopic level.\nWhen an asset is digital, and an image at that, \u0026ldquo;ownership\u0026rdquo; comes with no priviledges. If you can use it as your twitter avatar, I can too. And unlike the real world, my avatar has the exact same pixel composition as yours.\nWhatever you can do it with it, I can. Except you now bear a financial loss in pursuit of this \u0026ldquo;ownership\u0026rdquo; because people told you it means something.\nYour \u0026lsquo;get-rich-quick\u0026rsquo; chances are miniscule The value of an NFT is what you believe it to be.\nCrypto evangelists would have you believe this too, except they\u0026rsquo;d word it very differently. But you can\u0026rsquo;t get the world to agree on this strange belief system where nearly identical 32x32 pixel people are supposed to encapsulate an \u0026ldquo;idea\u0026rdquo; worth thousands of dollars.\nTo most, it just won\u0026rsquo;t make sense. Why should this clump of pixels cost 1M$?\nWhy should we collectively enforce this belief? What can we achieve with this new school of thought that we couldn\u0026rsquo;t before?\nSome crypto evangelists answer this with \u0026ldquo;It can make you rich!\u0026rdquo;. There is a nugget of truth to that, but it\u0026rsquo;s a very twisted statement that conceals more than it shows. We\u0026rsquo;ve to realize that this value doesn\u0026rsquo;t come from nowhere. For you to have gained in this flaky landscape, several others had to lose. And if general probability theory is anything to go by, you\u0026rsquo;re more likely to find yourself in the losing lot.\nMLM scams and pyramid schemes play a surprisingly similar game, but enough people have already drawn this analogy so that I don\u0026rsquo;t have to.\nEngineering NFTs CAN be altered Unknown to most regular consumers of crypto, the actual items represented by NFTs they own aren\u0026rsquo;t actually stored on a blockchain. i.e - the million dollar ape JPEG someone spent their life savings on is physically located somewhere outside Ethereum. They\u0026rsquo;re stored on a separate database which could be centralised (but generally isn\u0026rsquo;t, like IPFS). The blockchain itself only stores a URI to the resource in question (say ipfs://foo/bar/orangutan.jpg).\nLook at Ethereum\u0026rsquo;s EIP-721 token standard. Once you\u0026rsquo;ve made your way through the document, you\u0026rsquo;ll realise there is nothing stopping a server from serving different files at different times of the day for the same URI. Or serving different files based on where the client requesting the resource is located. There is even a word for this act, it starts with a c, ends with an r and rhymes with \u0026ldquo;tensor\u0026rdquo;. See this NFT by Moxie Marlinspike as an example.\nWeb3 is not technically feasible Ever so often you\u0026rsquo;ll cross web3 enthusiasts on twitter who claim the internet will be decentralized in the near future. That there will be no institutional control and a governments\u0026rsquo; powers over social media will cease to exist. And they claim this will be by virtue of a blockchain driven internet, that runs on gas fees.\nIt just isn\u0026rsquo;t possible. An advertisement driven web, no matter how terrible, is still far superior to one that is gas fees driven. When texting, people will always prefer ads to paying out of their own pocket.\nHowever, lets leave the human factors aside for a moment. Let\u0026rsquo;s imagine a world where humans willingly pay to post instagram selfies. Even in that universe, blockchain is incapable of supporting such an infrastructure.\nBlockchains are SLOW. They\u0026rsquo;re simply inefficient when put up against traditional databases and the decades old client-server architechture. What\u0026rsquo;s even worse is traditional scaling and optimization techniques do not apply to a blockchain. The optimizations that do exist (indexers) are centralized and beat the whole point of web3.\nA blockchain is a large append-only merkle tree that needs the computing power of a suburb to confirm a group of transactions, and even then it can take minutes depending on the implementation. For highly critical transactions, you\u0026rsquo;ve to wait for 5-6 rounds of \u0026ldquo;confirmation\u0026rdquo; before gaining reasonable confidence in the operation you just performed.\nAnyone who has actually studied this subject in appropriate detail would tell you it is impossible for such inefficient technology to withhold traffic on sites like reddit, discord, twitter, facebook, 4chan, youtube etc.\nThe more energy efficient consensus algorithms, like \u0026ldquo;Proof of Stake\u0026rdquo;, have a different kind of flaw. They favor miners (called bakers on the Tezos chain) who own more coin. A classic \u0026ldquo;rich get richer\u0026rdquo; scheme.\nThis is not to say blockchain is completely useless. It might be used for problems such as food contamination tracing, and verifying ownership of legal documents. However the world today is in a frenzy to use it in all the places where it doesn\u0026rsquo;t belong.\n","permalink":"https://anubhavp.dev/blog/posts/pages/infeasibleweb3/","summary":"During my short stint as a blockchain developer, I\u0026rsquo;ve learned a lot and have met amazing people. While I acknowledge the skill and reverence of some developers in this domain, I still remain uncharmed by the zeal of web3.\nIf you\u0026rsquo;re a blockchain enthusiast reading this, know that I understand where you stand. I\u0026rsquo;ve been in your shoes, and I draw my opinions from personal encounters with the crypto ecosystem. What I ask of you as a peer then, is that you put your tech under a lens of scrutiny and sever any bonds that may develop into religious fanaticism.","title":"Why is Web3 a sham?"}]