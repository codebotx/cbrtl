<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust: The next C++ ? | Shitpost.in</title><meta name=keywords content="project"><meta name=description content="Rust is a multi-paradigm systems programming language created to ensure high performance similar to that offered by C and C++ but with emphasis on code safety"><meta name=author content="Anubhab Patnaik"><link rel=canonical href=https://anubhavp.dev/blog/posts/pages/rust/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.min.4b3654b1e7f52ee40f91deb1259c5bf97d2d0b5568e3d5a85ecb142c731894b7.css integrity="sha256-SzZUsef1LuQPkd6xJZxb+X0tC1Vo49WoXssULHMYlLc=" rel="preload stylesheet" as=style><link rel=icon href=https://anubhavp.dev/blog/favicon.ico><link rel=apple-touch-icon href=https://anubhavp.dev/blog/apple-touch-icon.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-F5NTM76P29"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-F5NTM76P29",{anonymize_ip:!1})}</script><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust: The next C++ ? | Shitpost.in"><meta name=twitter:description content="Rust is a multi-paradigm systems programming language created to ensure high performance similar to that offered by C and C++ but with emphasis on code safety"><meta property="og:title" content="Rust: The next C++ ? | Shitpost.in"><meta property="og:description" content="Rust is a multi-paradigm systems programming language created to ensure high performance similar to that offered by C and C++ but with emphasis on code safety"><meta property="og:type" content="article"><meta property="og:url" content="https://anubhavp.dev/blog/posts/pages/rust/"><meta property="og:image" content="https://anubhavp.dev/blog/papermod-cover.png"><meta property="og:image" content="https://anubhavp.dev/favicon.ico"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-14T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-14T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://anubhavp.dev/blog/posts/"},{"@type":"ListItem","position":2,"name":"Rust: The next C++ ?","item":"https://anubhavp.dev/blog/posts/pages/rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust: The next C++ ? | Shitpost.in","name":"Rust: The next C\u002b\u002b ?","description":"Rust is a multi-paradigm systems programming language created to ensure high performance similar to that offered by C and C++ but with emphasis on code safety","keywords":["project"],"wordCount":"2839","inLanguage":"en","datePublished":"2022-10-14T00:00:00Z","dateModified":"2022-10-14T00:00:00Z","author":{"@type":"Person","name":"Anubhab Patnaik"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://anubhavp.dev/blog/posts/pages/rust/"},"publisher":{"@type":"Organization","name":"Shitpost.in","logo":{"@type":"ImageObject","url":"https://anubhavp.dev/blog/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list-page{background:var(--theme)}.list-page:not(.dark)::-webkit-scrollbar-track{background:0 0}.list-page:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body class="type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="auto",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://anubhavp.dev/blog/ accesskey=h title="Shitpost.in (Alt + H)">Shitpost.in</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://anubhavp.dev/blog/archives/ title=Archive>Archive</a></li><li><a href=https://anubhavp.dev/blog/search/ title="Search (Alt + /)" data-no-instant accesskey=/>Search</a></li><li><a href=https://anubhavp.dev/blog/tags/ title=Tags>Tags</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://anubhavp.dev/blog/>Home</a>&nbsp;Â»&nbsp;<a href=https://anubhavp.dev/blog/posts/>Posts</a></div><h1 class=post-title>Rust: The next C++ ?</h1><div class=post-description>Rust is a multi-paradigm systems programming language created to ensure high performance similar to that offered by C and C++ but with emphasis on code safety</div><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>October 14, 2022</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select:text"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z" style="user-select:text"/><line x1="7" y1="7" x2="7" y2="7" style="user-select:text"/></svg>
<span class=post-tags><a href=https://anubhavp.dev/blog/tags/project/>project</a></span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>14 min</span></span></div></header><div class="toc side left"><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#programming-languages-and-their-working aria-label="Programming Languages and their working">Programming Languages and their working</a><ul><li><a href=#compilers-and-interpreters aria-label="Compilers and interpreters">Compilers and interpreters</a></li><li><a href=#compiled-vs-interpreted-languages aria-label="Compiled Vs Interpreted languages">Compiled Vs Interpreted languages</a></li></ul></li><li><a href=#c-the-king-of-programming-languages aria-label="C++: The king of programming languages">C++: The king of programming languages</a></li><li><a href=#memory-management-in-programming-languages aria-label="Memory Management in programming languages">Memory Management in programming languages</a><ul><li><a href=#c aria-label=C++>C++</a></li><li><a href=#garbage-collection aria-label="Garbage collection">Garbage collection</a></li></ul></li><li><a href=#rust aria-label=Rust>Rust</a><ul><li><a href=#rust--c- aria-label="Rust &amp;gt; C++ ?">Rust > C++ ?</a></li></ul></li></ul></div></details></div><div class=post-content><p>Rust is a multi-paradigm systems programming language created to ensure high performance similar to that offered by C and C++, but with emphasis on code safety, the lack of which is probably why C and C++ are painful to deal with. It accomplishes these goals of being memory safe without using garbage collection. It is also an ahead-of-time compiled language, which means that you can compile a rust program, give it to someone else, and they can run it even without Rust installed. However, Rust has more than just memory safety on its side. High performance while processing large amounts of data, support for concurrent programming, with an effective compiler are other reasons why well-known software heavyweights such as Firefox, Dropbox, Cloudflare, and many startups and large corporations use Rust in production.</p><p>Before I explain a whole lot about programming languages and their working, some questions that may come to your mind are:</p><ol><li>If Rust is created to achieve performance similar to that offered by C++, then why not use C++ instead?</li><li>I know Java, JavaScript, and Python to be more popular choices amongst peers. Why not use those instead?</li><li>What about new languages like Go, Kotlin, Swift, etc.?</li></ol><p>To answer these questions, let us first go through how a programming language works.</p><h2 id=programming-languages-and-their-working>Programming Languages and their working<a hidden class=anchor aria-hidden=true href=#programming-languages-and-their-working>Â¶</a></h2><p>A programming language is a set of instructions that can be used to interact with and control a computer. These languages can be used for a multitude of purposes, such as creating a website, analyzing data, writing a program to solve a mathematical problem, creating a game, piloting a car, building a robot, making rockets take off, controlling spacecraft and the list goes on. A computer, even though can control a rover on Mars, detect an incoming ballistic missile, and detonate it before it reaches you, cannot understand English, or anything else except <strong>&lsquo;0&rsquo;</strong> & <strong>&lsquo;1&rsquo;</strong>. Computers can be thought of to be made up of tiny switches, and can be either &lsquo;on&rsquo; (1) or &lsquo;off&rsquo; (0) called <strong>&lsquo;bits&rsquo;</strong>. Whatever instruction you want to execute on a computer, has to be converted into a series of &lsquo;0&rsquo; and &lsquo;1&rsquo; before it can be executed. Even a simple &ldquo;Hi&rdquo; is parsed as <strong>01001000 01101001</strong>. Yes, this is what Siri replies when you <em>Hey Siri</em>. Since the English language is vast and complicated, it is not possible to convert it into a series of &lsquo;0&rsquo; and &lsquo;1&rsquo; directly. A subset of English or any other language is created, which is called a <strong>programming language</strong>. High-Level Programming Languages have english like syntax and are designed to be easy to read and write, whereas low-Level Programming Languages are designed to be easy for the computer to understand. To make things easier for us, there are tools that convert whatever we want the computer to do into a series of &lsquo;0&rsquo; and &lsquo;1&rsquo;. This series of &lsquo;0&rsquo; and &lsquo;1&rsquo; is then executed by the computer.</p><h3 id=compilers-and-interpreters>Compilers and interpreters<a hidden class=anchor aria-hidden=true href=#compilers-and-interpreters>Â¶</a></h3><p>A <strong>compiler</strong> or an <strong>interpreter</strong> is a tool that converts a program written in a programming language <em>(source code)</em> into a series of &lsquo;0&rsquo; and &lsquo;1&rsquo; that can be executed by a computer. What creates a difference between a compiler and an interpreter is the way they work. A compiler converts the entire program into a series of &lsquo;0&rsquo; and &lsquo;1&rsquo; <em>(machine code)</em> and then executes it. An interpreter, on the other hand, converts the program line by line and executes it.</p><p><strong>Why did we need interpreters?</strong></p><p>Compiled languages need a âbuildâ step. You need to compile your program before you can run it. To run your program on a different computer, you will have to compile it on that computer as well. Interpreters run through a program line by line and execute each command. You can run a program without having to compile it first. This makes it easier to run programs on different computers.</p><p>Another notable disadvantage of compilers is <strong>platform dependency</strong> of the generated binary code. Compilers are designed to be CPU specific and run on a specific CPU architecture. This means that if you want to run a program on a different CPU architecture, you will have to compile it again.</p><p><strong>Why do we still make use of compilers ?</strong></p><p>Compilers are designed to be CPU specific, and as a result, they tend to be a lot <strong>faster and more efficient</strong> than interpreters. They also give the developer <strong>more control</strong> over hardware aspects, like memory management and CPU usage.</p><p>A compiler is faster and more efficient than an interpreter, but an interpreter is easier to write than a compiler.</p><h3 id=compiled-vs-interpreted-languages>Compiled Vs Interpreted languages<a hidden class=anchor aria-hidden=true href=#compiled-vs-interpreted-languages>Â¶</a></h3><p>Interpreted languages were once significantly slower than compiled languages. But, with the development of <a href=https://guide.freecodecamp.org/computer-science/just-in-time-compilation>just-in-time compilation</a>, that gap is shrinking. Modern scripting languages like Python and JavaScript are compiled to machine code at runtime using both compilers and interpreters, which makes them as fast as compiled languages. They are first compiled to an intermediate representation called <strong>bytecode</strong>, and then interpreted by a virtual machine which converts it to machine code.</p><p>If you&rsquo;re wondering what language should you choose to build your next project with, ask yourself this: what kind of platform do I want to run the application in? If you want to run your application on a web browser, you should use JavaScript or TypeScript. If you want to run your application on a server, you may want to use Python or Go. In a mobile device, Swift or Kotlin might be the way to go. C++ is used for building complex applications and systems software, such as operating systems, browsers, and video games which require a heavy performance overhead.</p><p><em>Rust</em>, <em>Go</em> and <em>C++</em> are popular compiled languages that are used for building high-performance applications. <em>Python</em> and <em>JavaScript</em> are popular interpreted languages that are used for building web applications.</p><p>The speed advantage of the compiled language such as Golang (Go) in comparison to an interpreted language such as Java is one of the reasons why organizations write their microservices in Go. In complex computing environments such as cloud computing environments, where users get charged for every clock cycle, it makes sense to use the most efficient deployment artifact.</p><h2 id=c-the-king-of-programming-languages>C++: The king of programming languages<a hidden class=anchor aria-hidden=true href=#c-the-king-of-programming-languages>Â¶</a></h2><p>C++ is a low-level, statically typed object-oriented language that allows you to have a good grasp of your computer&rsquo;s resources and utilize them at your convenience. Since it is a compiled language, it surpasses the performance of most of the other interpreted languages. It is an extremely powerful language and is used in many applications such as operating systems, video games, the development of compilers and interpreters, etc. It has a huge community and is one of the most popular languages in the world.</p><p>Reasons why C++&rsquo;s performance is unparalleled:</p><ol><li>A compiled language. C++ is extremely fast because it is a compiled language.</li><li>A low-level language. It allows you to cheaply use computing resources.</li><li>Statically typed. It allows the compiler to optimize the code.</li><li>Object-oriented programming. It allows you to create reusable code.</li><li>A general purpose language. It can be used to create any kind of application.</li></ol><p>The issue with C++ boils down to how it <strong>manages memory</strong>. C++ is prone to memory leaks and dangling pointers, if not used properly.</p><h2 id=memory-management-in-programming-languages>Memory Management in programming languages<a hidden class=anchor aria-hidden=true href=#memory-management-in-programming-languages>Â¶</a></h2><p><strong>Variables</strong> are named memory locations that store data. A variable is a container that holds a value. The value can be of any type, such as <em>integer</em>, <em>float</em>, <em>character</em>, etc. Example:</p><pre><code>int a = 10;
float b = 10.5;
char c = 'a';
</code></pre><p>Computer programs need to allocate memory to store variables, data values, and data structures and deallocate memory when done using them. Memory is also used to store the program itself and the run-time system needed to support it. Programming languages can be categorized as those which provide <strong>automatic memory management</strong> and those which ask the programmer to allocate and <strong>free memory manually</strong>. Requiring the programmer to manage memory manually leads to a simpler compiler and run-time but requires more work from the programmer and is more error-prone. While automatic memory management is more convenient for the programmer, it is also more complex and slower. This is achieved by the use of <strong>garbage collection</strong>.</p><h3 id=c>C++<a hidden class=anchor aria-hidden=true href=#c>Â¶</a></h3><p>C++ is a low-level language with manual memory management. C++ programs manually allocate and free memory using <strong>pointers</strong>.</p><p><strong>Pointers</strong>
Pointers are variables that store the <strong>address</strong> of another variable and access the memory location of a variable. Pointers are used to pass large data structures to functions, to return multiple values from a function, to dynamically allocate memory, etc. Since there is no automatic memory management in C++, you need to be responsible for allocating and freeing memory. This process is achieved using the <strong>malloc</strong>, <strong>calloc</strong>, <strong>new</strong> and <strong>delete</strong> keywords.</p><p>With manual memory management, a few things can go wrong like memory leaks and dangling pointers. The dangling pointer problem arises when there is an attempt to use a pointer after it has been freed. Dangling pointer errors can arise whenever there is an error in the control flow logic of a program. The use of a pointer before allocation may be a fatal run-time error. Use after deallocation is not always fatal but neither of these is a good thing.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span style=display:flex><span><span></span>  <span>int</span> main()  
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span>int</span> *ptr=(<span>int</span> *)malloc(<span style=font-weight:700>sizeof</span>(<span>int</span>));  
</span></span><span style=display:flex><span>    <span>int</span> a=560;  
</span></span><span style=display:flex><span>    ptr=&amp;a;  
</span></span><span style=display:flex><span>    free(ptr);  
</span></span><span style=display:flex><span>    <span style=font-style:italic>// dangling pointer
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    printf(<span style=font-style:italic>&#34;%d&#34;</span>,*ptr);
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span> 0;  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>The above code will produce a segmentation fault since the pointer is pointing to a memory location that has been freed. To avoid this, we can set the pointer to NULL after freeing it.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span>    free(ptr);
</span></span><span style=display:flex><span>    ptr=NULL;
</span></span></code></pre></div><p>Memory leaks and dangling pointer bugs are some reasons why C++ is not preferred for applications that require a lot of memory management. To avoid such issues, languages that provide automatic memory management are preferred over C++. Scripting languages manage memory using a <strong>garbage collector</strong>.</p><h3 id=garbage-collection>Garbage collection<a hidden class=anchor aria-hidden=true href=#garbage-collection>Â¶</a></h3><p>Garbage is a memory that was once used by objects but will never be read or written by the program again. A garbage collector (GC) is a background process that provides automatic memory management for modern languages by taking care of the allocation and deallocation of a programâs computer memory resources. As a result, certain categories of bugs are eliminated or substantially reduced such as:-</p><p><strong>Dangling pointer bugs</strong> - a piece of memory is freed, but the objects still have references â one of these references is used in the program.</p><p><strong>Double-free bugs</strong> â the program attempts to free a piece of memory that has already been freed.</p><p><strong>Memory leaks</strong> â if a program does not free memory that is no longer referenced by any object, it can lead to memory exhaustion over time.</p><p>Garbage collection seemed like a really good solution to the memory leak issues occurring in low-level languages such as C/C++ but, it had a few CPU issues. CPU usage increases when a significant amount of CPU time is spent in a garbage collection. <em>Heap</em> is the memory that is used to allocate memory dynamically as opposed to the <em>stack</em> memory which is used to store the local variables. Local memory is quite automatic and local variables are allocated automatically. An increased allocation rate of objects on the managed heap causes garbage collection to occur more frequently.</p><p>Here are a few types of Garbage collectors:</p><p><strong>Mark & Sweep GC</strong>(Tracing GC): Its a two-phase algorithm that first marks objects that are being referenced as âaliveâ and in the next phase frees the memory of objects that are not alive. JVM, C#, Ruby, JavaScript, and Golang employ this approach. JavaScript engines like V8 use a Mark & Sweep GC along with Reference counting GC to complement it. This kind of GC is also available for C & C++ as an external library.</p><p><strong>Reference counting GC</strong>: Every object gets a reference count which is incremented or decremented as references to it change. Garbage is collected when the count becomes zero. This is not preferred as it cannot handle cyclic references. PHP, Perl, and Python use this kind of GC with workarounds to overcome cyclic references. This type of GC can be enabled for C++ as well.</p><p><strong>Automatic Reference Counting(ARC)</strong>: Similar to Reference counting GC but instead of running a runtime process at a specific interval the retain and release instructions are inserted to the compiled code at compile-time and when an object&rsquo;s reference becomes zero, it is cleared automatically as a part of the code execution. It also cannot handle cyclic references and relies on the developer. Its a feature of the Clang compiler and provides ARC for Objective C & Swift.</p><p><strong>Resource Acquisition is Initialization (RAII)</strong>: Objects and varibales are <em>scoped</em>, an objectâs memory allocation is tied to its lifetime, which is from construction until destruction. It was introduced in C++ and is also used by Ada and Rust.</p><h2 id=rust>Rust<a hidden class=anchor aria-hidden=true href=#rust>Â¶</a></h2><p>Rust is a general purpose systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. It is a multi-paradigm language that supports imperative, functional, and object-oriented programming. Rust is not only used to create low-level systems software such as operating systems, device drivers, and embedded software,but also used to create high-level applications such as web servers, command-line tools, and graphical user interfaces.</p><p>Rust builds on <strong>RAII</strong>( Resource Acquisition is Initialization) to provide automatic memory management. RAII is a programming technique that uses the lifetime of an object to manage the lifetime of its resources. In Rust, the compiler ensures that the memory is freed as soon as the object goes out of scope. This is achieved by the use of <strong>smart pointers</strong>. Rust implements borrow checking and ownership rules to ensure that memory is freed as soon as the object goes out of scope. Additionally, Rust also provides a <strong>garbage collector</strong> that can be used to free memory when the object goes out of scope.</p><blockquote><p>Ownership and Borrowing</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span>#[derive(Debug)]</span>
</span></span><span style=display:flex><span><span style=font-weight:700>struct</span> <span style=font-weight:700>Employee</span> {
</span></span><span style=display:flex><span>    id : <span>i32</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>fn</span> main() {
</span></span><span style=display:flex><span>    <span style=font-weight:700>let</span> a = Employee{id: 43} ;
</span></span><span style=display:flex><span>    <span style=font-weight:700>let</span> b  = a ;
</span></span><span style=display:flex><span>    <span style=font-style:italic>// println!(&#34;{:?}&#34;, a) ; // error: borrow of moved value: `a`
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    <span style=font-weight:700>let</span> c= a ;
</span></span><span style=display:flex><span>    <span style=font-style:italic>// println!(&#34;{:?}&#34;, a) ; // error: borrow of moved value: `a`
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>} 
</span></span></code></pre></div><blockquote><p>RAII</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=font-weight:700>fn</span> main() {
</span></span><span style=display:flex><span>        <span style=font-weight:700>let</span> foo = <span style=font-style:italic>&#34;value&#34;</span>; <span style=font-style:italic>// owner is foo and is valid within this method
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        <span style=font-style:italic>// bar is not valid here 
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=font-weight:700>let</span> bar = <span style=font-style:italic>&#34;bar value&#34;</span>; <span style=font-style:italic>// owner is bar and is valid 
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>//within this block scope
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            println!(<span style=font-style:italic>&#34;value of bar is {}&#34;</span>, bar); <span style=font-style:italic>// bar is valid 
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>//here
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            println!(<span style=font-style:italic>&#34;value of foo is {}&#34;</span>, foo); <span style=font-style:italic>// foo is valid 
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>            <span style=font-style:italic>//here
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        println!(<span style=font-style:italic>&#34;value of foo is {}&#34;</span>, foo); <span style=font-style:italic>// foo is valid here
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        println!(<span style=font-style:italic>&#34;value of bar is {}&#34;</span>, bar); <span style=font-style:italic>// bar is not valid 
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>        <span style=font-style:italic>//here as its out of scope
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>    }
</span></span></code></pre></div><h3 id=rust--c->Rust > C++ ?<a hidden class=anchor aria-hidden=true href=#rust--c->Â¶</a></h3><p>C++ is a high-performance, general-purpose programming language that has been widely used for decades. It is known for its flexibility and ability to handle low-level tasks, making it a popular choice for systems programming and game development. C++ also has a large and active community, which means that there are many libraries and resources available for developers to use. Rust, on the other hand, is a relatively <strong>new programming language</strong> that was first released in 2010. It is designed to be a safe and concurrent language, with a strong focus on preventing common programming errors such as null pointer dereferences and buffer overflows.</p><p>Will rust replace C++ anytime soon? <strong>No</strong>. Rust is a relatively new language and is still in its early stages of development. It is not yet widely used in production, and there are still many features that are missing. However, it is gaining popularity and is being used in many large projects, such as Firefox and Servo. C++ has been widely used for decades and has a vast amount of <em>legacy code</em>, making it difficult for Rust to replace it. Rust is still a relatively new language, and its adoption in the industry has not yet reached the level of C++, which is widely used across many industries. C++ has a much larger community and ecosystem, with a wealth of libraries, tools, and resources, making it easier for developers to find help and resources. C++ has a mature set of development tools, such as compilers, debuggers, and integrated development environments, which are widely used and well-established. Rust&rsquo;s tooling is still evolving and may not be as mature or widely used as C++.</p><p>Coming back to our questions that we were pondering upon earlier, now we get that compiled languages are preferred over interpreted languages as they are much faster and hence C++/ Go are preferred over Python/JavaScript. While C++ is extremely fast, it is also prone to memory leaks. Other languages such as Rust and Go offer better automatic memory management. Go implements a garbage collector which has a CPU usage overhead while Rust builds over RAII and implements borrow checking and ownership rules to ensure that memory is freed as soon as the object goes out of scope. Rust also provides a garbage collector that can be used to free memory when the object goes out of scope.</p></div><footer class=post-footer><nav class=paginav><a class=next href=https://anubhavp.dev/blog/posts/pages/metamuiwallet/><span class=title>Next Page&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span><br><span>Decentralization in MetaMUI Wallet: A Case Study</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://anubhavp.dev/blog/>Shitpost.in</a></span><span style=display:inline-block;margin-left:1em>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/blog/js/medium-zoom.min.js data-no-instant></script>
<script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>(function(){const a="1"=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>